
### === Forest functions synthesis dataset homogenizer === ###

# Author(s): Fabio Benedetti, Marc Beringer, Paul Armando Gilmour Rivas Luginbühl, Noëlle Schenk, Bruno Ximenes Pinho, Caterina Penone
# Last update: 16/01/2025
# Purpose:   Load the wide version of the synthesis dataset generated with the R script "forest_functions_synthesis.R" 
#           made by Marc Beringer. 
#           Use "forest_functions_helper.txt" generated by "forest_functions_helper.R" and the HIVE metadata excel sheet
#           to convert the wide version of the dataset to a long version. 
#           Make sure that the names of the Functions match between the HIVE table, the forest_functions_helper table and 
#           the final long version of the forest functins dataset.

### === libraries === ### 
library("tidyverse")
library("data.table")
library("reshape2")
### ===== ###

### === working directory === ### 
# Adjust to your own directory if needed 
setwd("/Users/fabiobenedetti/Desktop/work/PostDocs/BEO-UniBern/Synthesis projects/Synthesis_dataset_functions_forest_09-04-24-main") 
### ===== ###

### Load the wide version of the data
forest_fun_syn_wide <- read.table("BE_synthesis_forest_dat_wide_Jan15_1.txt", header = T, sep = "\t")
# Check colnames, dimension, range of values etc.
names(forest_fun_syn_wide) # 77 functions and 4 metadata variables
dim(forest_fun_syn_wide) # 151x81
summary(forest_fun_syn_wide)
str(forest_fun_syn_wide)


### Load the forest_fun_helper table
forest_fun_helper <- read.table("forest_functions_helper_16.01.25.txt", header = T, sep = "\t")
# Check names, dimensions etc.
dim(forest_fun_helper)
str(forest_fun_helper)
head(forest_fun_helper)
# forest_fun_helper

### Examine the dataID levels
# unique(forest_fun_helper$dataID) # looks about right
# summary(factor(forest_fun_helper$dataID)) # Note: 4444 = new synthesis dataset
# forest_fun_helper[is.na(forest_fun_helper$dataID),] # No NAs

### Examine 
# unique(forest_fun_helper$codedYear)
# NOTES:
# - codedYear == 4444 --> averaged across years (keep as is, do not convert to NA)

# The final forest functions synthesis dataset should have the following columns:
# Plot (e.g. AEW01), Plot_bexis (e.g. AEW1), Function, Value, Year, Dataset_ID and Dataset_Version


### 26/11/24: Correct the variables names in 'forest_fun_syn_wide' so they match the names in 'forest_fun_helper'
names(forest_fun_syn_wide) # 81 names (77 functions, 4 metadata)
# vs.
unique(forest_fun_helper$Function_Name_Year) # 81 names
## (all 81 are functions, 4 variables listed in the METADATA file were not added to the synthesis collection)

# Assess overlap
intersect(names(forest_fun_syn_wide), unique(forest_fun_helper$Function_Name_Year))
### Problem: High overlap as should be (n = 68; 84%) 
### R code below fixes that issue of the few non matching variable names

### One by one, check names of forest_fun_syn_wide against unique(forest_fun_helper$AggregatedColumnName)
names(forest_fun_syn_wide)
## Output: 
#  [1] "Plot"
#  [2] "Plot_bexis"
#  [3] "exploratory"
#  [4] "habitat"
#  [5] "Root_decomposition"
#  [6] "Dung_removal"
#  [7] "Seed_depletion"
#  [8] "Browsing_percentage"
#  [9] "Insect_herbivory_total_damaged_area"
# [10] "Insect_herbivory_total_damaged_ST"
# [11] "Insect_herbivory_total_damaged_area_H"
# [12] "caterpillars_predation"
# [13] "Barkbeetle_antagonist_ratio"
# [14] "Soil_beta_glucosidase"
# [15] "Soil_Nacetyl_glucosaminidase"
# [16] "Soil_xylanase"
# [17] "Soil_carbon_fluxes"
# So far so good

# [18] "soil_respiration_2011"
# [19] "soil_respiration_2017"
# [20] "soil_respiration_2018"
# [21] "soil_respiration_2019"
# Capital 'S' for soil 
names(forest_fun_syn_wide)[18] <- "Soil_respiration_2011"
names(forest_fun_syn_wide)[19] <- "Soil_respiration_2017"
names(forest_fun_syn_wide)[20] <- "Soil_respiration_2018"
names(forest_fun_syn_wide)[21] <- "Soil_respiration_2019"

# [22] "Average_soil_respiration"
# [23] "Methane_oxidation"
# [24] "microbial_C"
# [25] "Fine_roots_C"
# [26] "soil_org_C_2011"
# [27] "soil_org_C_2014"
# [28] "Average_soil_org_C"
# [29] "Total_litter_C_2015"
# [30] "Total_litter_C_2016"
# [31] "Total_litter_C_2017"
# [32] "Total_litter_C_2018"
# [33] "Average_Total_litter_C"
# All OK so far

# [34] "soil_potential_nitrification_2014"
# [35] "soil_potential_nitrification_2016"
# Capital S again here
names(forest_fun_syn_wide)[34] <- "Soil_potential_nitrification_2014"
names(forest_fun_syn_wide)[35] <- "Soil_potential_nitrification_2016"

# [36] "ammonia_oxidizing_archaea"
# [37] "ammonia_oxidizing_bacteria"
# [38] "nitrite_oxidizing_nitrobacter"
# [39] "nitrite_oxidizing_nitrospira"
# [40] "soil_nitrite_fluxes"
# [41] "soil_ammonia_fluxes"
# [42] "Soil_N_retention"
# [43] "microbial_N"
# [44] "Soil_N_2011"
# [45] "Soil_N_2014"
# [46] "Average_Soil_N"
# [47] "Fine_roots_N"
# [48] "Total_litter_N_2015"
# [49] "Total_litter_N_2016"
# [50] "Total_litter_N_2017"
# [51] "Total_litter_N_2018"
# [52] "Average_Total_litter_N"
# [53] "Soil_phosphatase_2011"
# [54] "Soil_phosphatase_2014"
# [55] "Average_soil_phosphatase"
# [56] "Soil_P_retention_2011"
# [57] "Soil_P_retention_2018"
# [58] "Soil_org_P_soluble"
# [59] "Soil_P_soluble"
# [60] "Soil_NaHCO3_P"
# [61] "microbial_P"
# [62] "Soil_OlsenPi_2014"
# [63] "Soil_OlsenPi_2021"
# [64] "Average_Soil_OlsenPi"
# [65] "Root_biomass_2011"
# [66] "Root_biomass_2014"
# [67] "Root_biomass_2017"
# [68] "litter_biomass_2015"
# [69] "litter_biomass_2016"
# [70] "litter_biomass_2017"
# [71] "litter_biomass_2018"
# [72] "litter_biomass_2019"
# [73] "litter_biomass_2020"
# [74] "litter_biomass_2021"
# [75] "litter_biomass_2022"
# [76] "Average_litter_biomass"
# [77] "Aboveground_biomass"

# [78] "Aboveground_C_stock"
# [79] "Aboveground_N_stock"
# [80] "Aboveground_P_stock"
# Remove the 'stock'
names(forest_fun_syn_wide)[78] <- "Aboveground_C"
names(forest_fun_syn_wide)[79] <- "Aboveground_N"
names(forest_fun_syn_wide)[80] <- "Aboveground_P"

# [81] "Productivity"
# OK

### Re-assess overlap now? Should be 100%...
setdiff(names(forest_fun_syn_wide),unique(forest_fun_helper$Function_Name_Year)) # Should return "Plot","Plot_bexis","exploratory","habitat"  
intersect(names(forest_fun_syn_wide),unique(forest_fun_helper$Function_Name_Year)) 
length(intersect(colnames(forest_fun_syn_wide),unique(forest_fun_helper$Function_Name_Year))) == (length(colnames(forest_fun_syn_wide))-4)
# Should return TRUE


### Now, convert the wide forest functions synthesis dataset into the long format, but keep the column names
# Use pivot_longer FUN
# Notes to self: pivot_longer() "lengthens" data, increasing the number of rows and decreasing the number of columns.
# 'cols' = Columns to pivot into longer format
# 'names_to' = character vector specifying the new column or columns to create from the information stored in the column names of data specified by cols
# 'values_to' = string specifying the name of the column to create from the data stored in cell values

long_dat <- forest_fun_syn_wide %>% 
  #remove the "exploratory" and "habitat" columns as they will not be in the final dataset
  subset(select = -c(exploratory,habitat)) %>% 
  #pivot all columns of the forest functions synthesis dataset longer
  pivot_longer(cols = c(3:ncol(.)), names_to = c("Function_Name_Year"), values_to = "Value")
 
# Check
dim(long_dat) # 11627x4
str(long_dat)
summary(long_dat)
names(long_dat) # names(forest_fun_helper)

# Compare to 'forest_fun_helper$AggregatedColumnName' ?
# intersect(unique(long_dat$Function_Name_Year), unique(forest_fun_helper$Function_Name_Year)) # should be 77
# setdiff(unique(long_dat$Function_Name_Year), unique(forest_fun_helper$Function_Name_Year)) # should return 0


### Second, merge with the 'forest_fun_helper' table by matching 'AggregatedColumnName2'
long_dat.1 <- merge(long_dat, forest_fun_helper, by = "Function_Name_Year", all.x = T)
# Check quickly
# head(long_dat.1)
# dim(long_dat.1) # 11627 x 8 (4 + 4 new variables)
# summary(long_dat.1)
# NAs in values? 
# long_dat.1[is.na(long_dat.1$Value),c("Function_Name_Year","Plot","Value")]
# unique(long_dat.1[is.na(long_dat.1$Value),"Function_Name_Year"]) # functions that were not measured in 100% of the forest EPs
# Is ok!

## Check dataseID
#summary(factor(long_dat.1$dataID)) # 906 NAs
#head(long_dat.1[is.na(long_dat.1$dataID),])
#unique(long_dat.1[is.na(long_dat.1$dataID),"Function_Name_Year"])
### Remember: 4444 --> averaged across different years/datasets for the present functions dataset
### No dataset ID yet.


### Third, remove "ColumnName" and reorder columns for convenience
long_dat.2 <- long_dat.1 %>% relocate(Plot, Plot_bexis, Function_Name, Function_Name_Year, Value, codedYear, dataID, Dataset_Version)
# typeof(long_dat.2$Value)

# Quick check as always
# dim(long_dat.2) # should be 11627 x 8
# head(long_dat.2)
# str(long_dat.2)
# Looks ok

### Fourth, rename columns for the upload on BExIS
names(long_dat.2)[names(long_dat.2) == "Function_Name_Year"] <- "Function_Year"
names(long_dat.2)[names(long_dat.2) == "codedYear"] <- "Year"
names(long_dat.2)[names(long_dat.2) == "dataID"] <- "Dataset_ID"

### Final checks 
# head(long_dat.2); tail(long_dat.2)
# summary(long_dat.2)
# summary(factor(long_dat.2$Function)) # no NA, good

## Check Plot levels 
unique(long_dat.2$Plot) # OK
summary(factor(long_dat.2$Plot)) # OK

## Check 'Function'
unique(long_dat.2$Function_Year) # OK
unique(long_dat.2$Function_Name) # OK

## Check 'Value'
summary(long_dat.2$Value) # Should the NAs be removed safely?
# long_dat.2[is.na(long_dat.2$Value),]

# Does 'Average_soil_potential_nitrification' show missing values ONLY? 
long_dat.2[long_dat.2$Function == "Browsing_percentage",] # nope :) good
long_dat.2[long_dat.2$Function == "Total_litter_N_2016",] # neither, good :)
# No need to remove the NAs then.

## Check Year
unique(long_dat.2$Year) # Replace 4444 by NA? No.

## Check Dataset_ID
unique(long_dat.2$Dataset_ID) # No NAS, good

### 16/01/25: COMMENT CROM BRUNO X. PINHO & CATARINA PENONE: 
### REMOVE ALL CAPS FROM THE FUNCTIONS NAMES (for simplicity)
# To uncapitalize the first letters
uncapitalize <- function(x) { paste0(tolower(substr(x, 1, 1)), substr(x, 2, nchar(x))) } # eo FUN
# Apply the function to the vector
# sapply(unique(long_dat.2$Function_Name), uncapitalize)
# sapply(unique(long_dat.2$Function_Year), uncapitalize)
# Apply to dataset
long_dat.2$Function_Name <- uncapitalize(long_dat.2$Function_Name)
long_dat.2$Function_Year <- uncapitalize(long_dat.2$Function_Year)
# unique(long_dat.2$Function_Year)

### 30/01/25: Cornelia asked to submit the data (as a .txt file) in the "type double" format. Therefore, the numbers can only have 13 characters.
### In R, "type double" refers to double-precision floating-point numbers, which can store decimal values.
### Since you need to ensure the numbers have at most 13 characters, including digits, decimal points, and possible minus signs, you must round them accordingly.
round_to_13 <- function(x) {
  # Handle missing values
  if (is.na(x)) {
    return(NA)  # Keep NA as character format
  }
  x_char <- as.character(x)  # Convert to character
  # If already within 13 characters, return as is
  if (nchar(x_char) <= 13) {
    return(x_char)
  }
  # Otherwise, iteratively reduce decimal places until it fits
  for (digits in 10:0) {  # Max 10 decimals (to be within 13 chars)
    rounded <- format(round(x, digits), scientific = FALSE, trim = TRUE)
    if (nchar(rounded) <= 13) {
      return(rounded)
    }
  }
  return("ERROR")  # Should never happen, but just in case
}

# tets with dummy dataset
dummy <- c(-0.56757586890000999987, 123.456789123456, NA, -987654.321987654, 3.14159265358979, 456789.123456,
        0.00010001, 1234.1, 10, 122.0002020202020202020202020, NA)
# Apply function to dataset
sapply(dummy, round_to_13)

long_dat.2$Value <- sapply(long_dat.2$Value, round_to_13)
#head(long_dat.2$Value)
#summary(as.numeric(long_dat.2$Value))

### Save the table, it is ready for upload on BExIS
write.table(long_dat.2, file = "synthesis_dataset_functions_forest_long_30.01.25.txt", quote = F, sep = "\t", row.names = F)


### =========================================================================================================
### =========================================================================================================
### =========================================================================================================